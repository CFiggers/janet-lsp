{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/caleb/projects/vscode/vscode-janet-plus-plus/janet-lsp/test/test-format-file-after.janet","languageId":"janet","version":1,"text":"(use judge)\n\n(defmacro- letv [bindings & body]\n  ~(do ,;(seq [[k v] :in (partition 2 bindings)] ['var k v]) ,;body))\n\n(defn- read-hex [n]\n  (scan-number (string \"0x\" n)))\n\n(defn- check-utf-16 [capture]\n  (let [u (read-hex capture)]\n    (if (and (>= u 0xD800)\n             (<= u 0xDBFF))\n      capture\n      false)))\n\n(def- utf-8->bytes\n  (peg/compile\n    ~{:double-u-esc (/ (* \"\\\\u\" (cmt (<- 4) ,|(check-utf-16 $)) \"\\\\u\" (<- 4))\n                       ,|(+ (blshift (- (read-hex $0) 0xD800) 10)\n                            (- (read-hex $1) 0xDC00) 0x10000))\n      :single-u-esc (/ (* \"\\\\u\" (<- 4)) ,|(read-hex $))\n      :unicode-esc (/ (+ :double-u-esc :single-u-esc)\n                      ,|(string/from-bytes\n                          ;(cond\n                             (<= $ 0x7f) [$]\n                             (<= $ 0x7ff)\n                             [(bor (band (brshift $ 6) 0x1F) 0xC0)\n                              (bor (band (brshift $ 0) 0x3F) 0x80)]\n                             (<= $ 0xffff)\n                             [(bor (band (brshift $ 12) 0x0F) 0xE0)\n                              (bor (band (brshift $ 6) 0x3F) 0x80)\n                              (bor (band (brshift $ 0) 0x3F) 0x80)]\n                             # Otherwise\n                             [(bor (band (brshift $ 18) 0x07) 0xF0)\n                              (bor (band (brshift $ 12) 0x3F) 0x80)\n                              (bor (band (brshift $ 6) 0x3F) 0x80)\n                              (bor (band (brshift $ 0) 0x3F) 0x80)])))\n      :escape (/ (* \"\\\\\" (<- (set \"avbnfrt\\\"\\\\/\")))\n                 ,|(get {\"a\" \"\\a\" \"v\" \"\\v\" \"b\" \"\\b\"\n                         \"n\" \"\\n\" \"f\" \"\\f\" \"r\" \"\\r\"\n                         \"t\" \"\\t\"} $ $))\n      :main (+ (some (+ :unicode-esc :escape (<- 1))) -1)}))\n\n(comment\n\n  \"ðŸ‘Ž\"\n  (json/encode \"ðŸ‘Ž\")\n  (json/decode (json/encode \"ðŸ‘Ž\"))\n\n  (encode \"ðŸ‘Ž\")\n  (decode (encode \"ðŸ‘Ž\")))\n\n(defn decode\n  ``\nReturns a janet object after parsing JSON. If keywords is truthy,\nstring keys will be converted to keywords. If nils is truthy, null\nwill become nil instead of the keyword :json/null.\n``\n  [json-source &opt keywords nils]\n\n  (def json-parser\n    {:null (if nils\n             ~(/ (<- (+ \"null\" \"Null\")) nil)\n             ~(/ (<- (+ \"null\" \"Null\")) :json/null))\n     :bool-t ~(/ (<- (+ \"true\")) true)\n     :bool-f ~(/ (<- (+ \"false\")) false)\n     :number ~(/ (<- (* (? \"-\") :d+ (? (* \".\" :d+)))) ,|(scan-number $))\n     :string ~(/ (* \"\\\"\" (<- (to (* (> -1 (not \"\\\\\")) \"\\\"\")))\n                    (* (> -1 (not \"\\\\\")) \"\\\"\"))\n                 ,|(string/join (peg/match utf-8->bytes $)))\n     :array ~(/ (* \"[\" :s* (? (* :value (any (* :s* \",\" :value)))) \"]\") ,|(array ;$&))\n     :key-value (if keywords\n                  ~(* :s* (/ :string ,|(keyword $)) :s* \":\" :value)\n                  ~(* :s* :string :s* \":\" :value))\n     :object ~(/ (* \"{\" :s* (? (* :key-value (any (* :s* \",\" :key-value)))) \"}\")\n                 ,|(from-pairs (partition 2 $&)))\n     :value ~(* :s* (+ :null :bool-t :bool-f :number :string :array :object) :s*)\n     :unmatched ~(/ (<- (to (+ :value -1))) ,|[:unmatched $])\n     :main ~(some (+ :value \"\\n\" :unmatched))})\n\n  (first (peg/match (peg/compile json-parser) json-source)))\n\n(def- bytes->utf-8\n  (peg/compile\n    ~{:four-byte (/ (* (<- (range \"\\xf0\\xff\")) (<- 1) (<- 1) (<- 1))\n                    ,|(bor (blshift (band (first $0) 0x07) 18)\n                           (blshift (band (first $1) 0x3F) 12)\n                           (blshift (band (first $2) 0x3F) 6)\n                           (blshift (band (first $3) 0x3F) 0)))\n      :three-byte (/ (* (<- (range \"\\xe0\\xef\")) (<- 1) (<- 1))\n                     ,|(bor (blshift (band (first $0) 0x0F) 12)\n                            (blshift (band (first $1) 0x3F) 6)\n                            (blshift (band (first $2) 0x3F) 0)))\n      :two-byte (/ (* (<- (range \"\\x80\\xdf\")) (<- 1))\n                   ,|(bor (blshift (band (first $0) 0x1F) 6)\n                          (blshift (band (first $1) 0x3F) 0)))\n      :multi-byte (/ (+ :two-byte :three-byte :four-byte)\n                     ,|(if (< $ 0x10000)\n                         (string/format \"\\\\u%04X\" $)\n                         (string/format \"\\\\u%04X\\\\u%04X\"\n                                        (+ (brshift (- $ 0x10000) 10) 0xD800)\n                                        (+ (band (- $ 0x10000) 0x3FF) 0xDC00))))\n      :one-byte (<- (range \"\\x20\\x7f\"))\n      :0to31 (/ (<- (range \"\\0\\x1F\"))\n                ,|(or ({\"\\a\" \"\\\\u0007\" \"\\b\" \"\\\\u0008\"\n                        \"\\t\" \"\\\\u0009\" \"\\n\" \"\\\\u000A\"\n                        \"\\v\" \"\\\\u000B\" \"\\f\" \"\\\\u000C\"\n                        \"\\r\" \"\\\\u000D\"} $)\n                      (string/format \"\\\\u%04X\" (first $))))\n      :backslash (/ (<- \"\\\\\") \"\\\\\\\\\")\n      :quote (/ (<- \"\\\"\") \"\\\\\\\"\")\n      :main (some (+ :0to31 :backslash :quote :one-byte :multi-byte))}))\n\n(defn- encodeone [encoder x depth]\n  (if (> depth 1024) (error \"recurred too deeply\"))\n  (cond\n    (= x :json/null) \"null\"\n    (bytes? x) (string \"\\\"\" (string/join (peg/match bytes->utf-8 x)) \"\\\"\")\n    (indexed? x) (string \"[\" (string/join (map |(encodeone encoder $ (inc depth)) x) \",\") \"]\")\n    (dictionary? x) (string \"{\" (string/join\n                                  (seq [[k v] :in (pairs x)]\n                                    (string (encodeone encoder k (inc depth)) \":\" (encodeone encoder v (inc depth)))) \",\") \"}\")\n    (case (type x)\n      :nil \"null\"\n      :boolean (string x)\n      :number (string x)\n      (error \"type not supported\"))))\n\n(defn encode\n  `` \nEncodes a janet value in JSON (utf-8). `tab` and `newline` are optional byte sequence which are used \nto format the output JSON. If `buf` is provided, the formated JSON is append to `buf` instead of a new buffer.\nReturns the modifed buffer.\n``\n  [x &opt tab newline buf]\n\n  (letv [encoder {:indent 0\n                  :buffer @\"\"\n                  :tab tab\n                  :newline newline}\n         ret (encodeone encoder x 0)]\n        (if (and buf (buffer? buf))\n          (buffer/push ret)\n          (thaw ret))))\n"}}}
